package com.min.edu;

//TODO 001 수학연산

/*
 *  / 나누기 division
 *  % modulus
 */

public class Arthmetic_Operation {	
	
	public void arthmetic() {
		float x = 3+2;	// => 5.0 나온다
		x = 3-2;	//1.0
		x = 3*2;	//6.0
		x = 3/2;	//1.0 컴퓨터는 정수연산처리와 실수연산처리가 다른 곳에서 한다. 몫만을 계산한다
		x = 7%2;	//1.0 나머지만 계산한다
		
	}
	
	//** 참여하는 연산의 타입!!!
	//	 리터럴값은 f는 float, l은 long을 나타냄 10l, 10f
	//	 가능하면 명시적 캐스팅을 통해 작성하는 것이 좋다 => 가독성 떄문에
	public void division_Sign() {
		//실수 연산의 경우 걸과를 예측하지 말고 타입을 확인해야 한다
		//참여하는 연산의 타입에 따라서 결과를 가져온다
		
		float x1 = 3/2;	//1.0 => 결과가 1.5가 나오게 만들고싶다?
		
		// 3/2 정수이기 떄문에 정수 연산 : 몫만 계산된다 1 -> 1.0변환
		// 부모 혹은 자식의 타입이 실수라면 => 실수연산이 발생한다
		
		//float x2 = 3/2.0; -> 오류가 남 : int/double => double 인데 float가 더 작아서
		float x2 = 3/2.0f;	//리터럴
		float x3 = (float)(3/2.0);	//명시적 캐스팅 = 3f/2
		
		// 정수타입 숫자 리터럴 10,16,8,2진수
		//int i1 = 10/10l; -> 오류남 : l은 숫자값(literal long의 크기로 변경)
		long i2 = 10/10;	// 리터럴/리터럴 => int크기 -=> 자동으로 입력 Promotion
		//int i3 = (long)10/10;	-> 리터럴 long으로 캐스팅 따라서 값을 long의 크기 / 리터럴 : 참여하는 타입에 따라서 결과가 다르다 => 결과는 long 으로 출력
		
		
		
		
		System.out.println();
		
		//리터럴의 정의
		//not computation value : 컴퓨터 번역하지 않고 입력 할 수 있는 값을 이야기한다
		//대입할 때 컴퓨터가 변경 없이 입력 할 수 있는 값 10 10진수 리터럴, 16, 8, 2,진수 => 메모리에 인식을 함
		//즉, 어디 묶여서 타입을 가지지 않는 것
		
		//저장될 때
		
	}
}

